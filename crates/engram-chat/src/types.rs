//! Core types and value objects for the conversational interface.
//!
//! Defines query intents, chat sessions, structured queries, and their
//! supporting types.

use serde::{Deserialize, Serialize};
use std::fmt;
use uuid::Uuid;

// =============================================================================
// Enums
// =============================================================================

/// Query intent classification for incoming chat messages.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum QueryIntent {
    /// User wants to search their captured data.
    Search,
    /// User wants to trigger an action (reminder, task, etc.).
    Action,
    /// User is asking a question about their data.
    Question,
    /// User is providing clarification for a previous query.
    Clarification,
}

impl fmt::Display for QueryIntent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            QueryIntent::Search => write!(f, "search"),
            QueryIntent::Action => write!(f, "action"),
            QueryIntent::Question => write!(f, "question"),
            QueryIntent::Clarification => write!(f, "clarification"),
        }
    }
}

impl std::str::FromStr for QueryIntent {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "search" => Ok(QueryIntent::Search),
            "action" => Ok(QueryIntent::Action),
            "question" => Ok(QueryIntent::Question),
            "clarification" => Ok(QueryIntent::Clarification),
            _ => Err(format!("Unknown query intent: {}", s)),
        }
    }
}

// =============================================================================
// Domain Structs
// =============================================================================

/// A time range for filtering queries.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeRange {
    /// Start of the range as epoch seconds.
    pub start: i64,
    /// End of the range as epoch seconds.
    pub end: i64,
}

/// A parsed and structured query extracted from a natural-language message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructuredQuery {
    /// The classified intent of the query.
    pub intent: QueryIntent,
    /// Detected topic keywords.
    pub topics: Vec<String>,
    /// Detected person references.
    pub people: Vec<String>,
    /// Optional time range filter.
    pub time_range: Option<TimeRange>,
    /// Optional content type filter (e.g. "screen", "audio").
    pub content_type: Option<String>,
    /// Optional application filter.
    pub app_filter: Option<String>,
    /// The original raw query text.
    pub raw_query: String,
}

/// A response generated by the chat engine.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatResponse {
    /// The generated answer text.
    pub answer: String,
    /// Source references supporting the answer.
    pub sources: Vec<SourceRef>,
    /// Confidence score (0.0 to 1.0).
    pub confidence: f32,
    /// Suggested follow-up queries.
    pub suggestions: Vec<String>,
}

/// A reference to a source chunk that contributed to a response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceRef {
    /// ID of the source chunk.
    pub chunk_id: Uuid,
    /// Timestamp of the source content.
    pub timestamp: String,
    /// Application that captured the source content.
    pub source_app: String,
    /// Relevance score of this source to the query (0.0 to 1.0).
    pub relevance_score: f32,
}

/// An active conversation session with context tracking.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConversationSession {
    /// Unique session identifier.
    pub id: Uuid,
    /// When the session started (epoch seconds).
    pub started_at: i64,
    /// When the last message was sent (epoch seconds).
    pub last_message_at: i64,
    /// Accumulated session context.
    pub context: SessionContext,
    /// Number of messages exchanged in this session.
    pub message_count: u32,
}

/// Contextual state accumulated during a conversation session.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SessionContext {
    /// Recent conversation turns for context.
    pub recent_turns: Vec<Turn>,
    /// Currently active topic, if any.
    pub active_topic: Option<String>,
    /// Currently active time range filter, if any.
    pub active_time_range: Option<TimeRange>,
    /// Currently active person filter, if any.
    pub active_person: Option<String>,
}

/// A single query-response exchange in a conversation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Turn {
    /// The parsed query from the user.
    pub query: StructuredQuery,
    /// The generated response.
    pub response: ChatResponse,
}

/// A persisted chat message row.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    /// Unique message identifier.
    pub id: Uuid,
    /// Session this message belongs to.
    pub session_id: Uuid,
    /// Role: "user" or "assistant".
    pub role: String,
    /// Message content text.
    pub content: String,
    /// JSON-encoded source references (optional).
    pub sources: Option<String>,
    /// JSON-encoded suggestions (optional).
    pub suggestions: Option<String>,
    /// When the message was created (epoch seconds).
    pub created_at: i64,
}

// =============================================================================
// API Types
// =============================================================================

/// Request body for the chat endpoint.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatRequest {
    /// The user's message text.
    pub message: String,
    /// Optional session ID for continuing a conversation.
    pub session_id: Option<Uuid>,
}

/// Response body for the chat endpoint.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessageResponse {
    /// The generated response.
    pub response: ChatResponseBody,
    /// The session ID (new or existing).
    pub session_id: Uuid,
}

/// The response payload within a chat message response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatResponseBody {
    /// The generated answer text.
    pub answer: String,
    /// Source references.
    pub sources: Vec<SourceRef>,
    /// Confidence score (0.0 to 1.0).
    pub confidence: f32,
    /// Suggested follow-up queries.
    pub suggestions: Vec<String>,
}

/// Response body for the chat history endpoint.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatHistoryResponse {
    /// Messages in chronological order.
    pub messages: Vec<ChatMessageRecord>,
}

/// A single message record in the chat history.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessageRecord {
    /// Role: "user" or "assistant".
    pub role: String,
    /// Message content text.
    pub content: String,
    /// ISO 8601 timestamp.
    pub timestamp: String,
    /// Source references (only for assistant messages).
    pub sources: Option<Vec<SourceRef>>,
    /// Suggested follow-up queries (only for assistant messages).
    pub suggestions: Option<Vec<String>>,
}

/// Response body for the chat sessions list endpoint.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatSessionsResponse {
    /// Active and recent sessions.
    pub sessions: Vec<ChatSessionSummary>,
}

/// Summary of a chat session.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatSessionSummary {
    /// Session identifier.
    pub id: Uuid,
    /// When the session started (ISO 8601).
    pub started_at: String,
    /// When the last message was sent (ISO 8601).
    pub last_message_at: String,
    /// Number of messages exchanged.
    pub message_count: u32,
}

// =============================================================================
// Configuration
// =============================================================================

/// Configuration for the conversational interface.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatConfig {
    /// Whether the chat interface is enabled.
    pub enabled: bool,
    /// Hotkey to activate voice query.
    pub voice_hotkey: String,
    /// Number of recent turns to keep in session context.
    pub context_turns: usize,
    /// Session timeout in minutes.
    pub session_timeout_minutes: u32,
    /// Maximum voice recording duration in seconds.
    pub max_voice_duration_seconds: u32,
    /// Default number of days to search back.
    pub default_search_days: u32,
    /// Maximum results per query.
    pub max_results_per_query: usize,
    /// LLM configuration.
    pub llm: ChatLlmConfig,
}

impl Default for ChatConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            voice_hotkey: "Ctrl+Shift+E".to_string(),
            context_turns: 5,
            session_timeout_minutes: 30,
            max_voice_duration_seconds: 30,
            default_search_days: 7,
            max_results_per_query: 10,
            llm: ChatLlmConfig::default(),
        }
    }
}

/// LLM-specific configuration for response generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatLlmConfig {
    /// Whether LLM-based response generation is enabled.
    pub enabled: bool,
    /// Path to the local LLM model.
    pub model_path: String,
    /// Maximum tokens for generated responses.
    pub max_tokens: u32,
    /// Temperature for response generation (0.0 to 1.0).
    pub temperature: f32,
}

impl Default for ChatLlmConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            model_path: String::new(),
            max_tokens: 512,
            temperature: 0.3,
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // ---- QueryIntent ----

    #[test]
    fn test_query_intent_display() {
        assert_eq!(QueryIntent::Search.to_string(), "search");
        assert_eq!(QueryIntent::Action.to_string(), "action");
        assert_eq!(QueryIntent::Question.to_string(), "question");
        assert_eq!(QueryIntent::Clarification.to_string(), "clarification");
    }

    #[test]
    fn test_query_intent_from_str() {
        assert_eq!(
            "search".parse::<QueryIntent>().unwrap(),
            QueryIntent::Search
        );
        assert_eq!(
            "action".parse::<QueryIntent>().unwrap(),
            QueryIntent::Action
        );
        assert_eq!(
            "question".parse::<QueryIntent>().unwrap(),
            QueryIntent::Question
        );
        assert_eq!(
            "clarification".parse::<QueryIntent>().unwrap(),
            QueryIntent::Clarification
        );
        assert!("invalid".parse::<QueryIntent>().is_err());
    }

    #[test]
    fn test_query_intent_from_str_error_message() {
        let err = "bogus".parse::<QueryIntent>().unwrap_err();
        assert_eq!(err, "Unknown query intent: bogus");
    }

    #[test]
    fn test_query_intent_serde_round_trip() {
        for variant in [
            QueryIntent::Search,
            QueryIntent::Action,
            QueryIntent::Question,
            QueryIntent::Clarification,
        ] {
            let json = serde_json::to_string(&variant).unwrap();
            let rt: QueryIntent = serde_json::from_str(&json).unwrap();
            assert_eq!(variant, rt);
        }
    }

    #[test]
    fn test_query_intent_display_from_str_round_trip() {
        for variant in [
            QueryIntent::Search,
            QueryIntent::Action,
            QueryIntent::Question,
            QueryIntent::Clarification,
        ] {
            let s = variant.to_string();
            let parsed: QueryIntent = s.parse().unwrap();
            assert_eq!(variant, parsed);
        }
    }

    #[test]
    fn test_query_intent_serde_json_format() {
        assert_eq!(
            serde_json::to_string(&QueryIntent::Search).unwrap(),
            "\"search\""
        );
        assert_eq!(
            serde_json::to_string(&QueryIntent::Clarification).unwrap(),
            "\"clarification\""
        );
    }

    #[test]
    fn test_query_intent_is_copy() {
        let qi = QueryIntent::Search;
        let qi2 = qi;
        assert_eq!(qi, qi2);
    }

    #[test]
    fn test_from_str_case_sensitive() {
        assert!("Search".parse::<QueryIntent>().is_err());
        assert!("ACTION".parse::<QueryIntent>().is_err());
    }

    #[test]
    fn test_from_str_empty_string() {
        assert!("".parse::<QueryIntent>().is_err());
    }

    #[test]
    fn test_serde_rejects_invalid_query_intent() {
        let result = serde_json::from_str::<QueryIntent>("\"bogus\"");
        assert!(result.is_err());
    }

    // ---- TimeRange ----

    #[test]
    fn test_time_range_serde_round_trip() {
        let tr = TimeRange {
            start: 1700000000,
            end: 1700003600,
        };
        let json = serde_json::to_string(&tr).unwrap();
        let rt: TimeRange = serde_json::from_str(&json).unwrap();
        assert_eq!(tr.start, rt.start);
        assert_eq!(tr.end, rt.end);
    }

    // ---- StructuredQuery ----

    #[test]
    fn test_structured_query_serde_round_trip() {
        let sq = StructuredQuery {
            intent: QueryIntent::Search,
            topics: vec!["rust".to_string(), "engram".to_string()],
            people: vec!["Alice".to_string()],
            time_range: Some(TimeRange {
                start: 1700000000,
                end: 1700003600,
            }),
            content_type: Some("screen".to_string()),
            app_filter: Some("Chrome".to_string()),
            raw_query: "what did Alice say about rust?".to_string(),
        };
        let json = serde_json::to_string(&sq).unwrap();
        let rt: StructuredQuery = serde_json::from_str(&json).unwrap();
        assert_eq!(sq.intent, rt.intent);
        assert_eq!(sq.topics, rt.topics);
        assert_eq!(sq.people, rt.people);
        assert_eq!(sq.raw_query, rt.raw_query);
        assert_eq!(sq.content_type, rt.content_type);
        assert_eq!(sq.app_filter, rt.app_filter);
    }

    #[test]
    fn test_structured_query_no_optionals() {
        let sq = StructuredQuery {
            intent: QueryIntent::Question,
            topics: vec![],
            people: vec![],
            time_range: None,
            content_type: None,
            app_filter: None,
            raw_query: "what happened today?".to_string(),
        };
        let json = serde_json::to_string(&sq).unwrap();
        let rt: StructuredQuery = serde_json::from_str(&json).unwrap();
        assert!(rt.time_range.is_none());
        assert!(rt.content_type.is_none());
        assert!(rt.app_filter.is_none());
    }

    // ---- ChatResponse ----

    #[test]
    fn test_chat_response_serde_round_trip() {
        let resp = ChatResponse {
            answer: "Here is what I found.".to_string(),
            sources: vec![SourceRef {
                chunk_id: Uuid::new_v4(),
                timestamp: "2026-02-19T10:00:00".to_string(),
                source_app: "Chrome".to_string(),
                relevance_score: 0.92,
            }],
            confidence: 0.85,
            suggestions: vec!["Tell me more".to_string()],
        };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatResponse = serde_json::from_str(&json).unwrap();
        assert_eq!(resp.answer, rt.answer);
        assert!((resp.confidence - rt.confidence).abs() < f32::EPSILON);
        assert_eq!(resp.sources.len(), rt.sources.len());
        assert_eq!(resp.suggestions, rt.suggestions);
    }

    // ---- SourceRef ----

    #[test]
    fn test_source_ref_serde_round_trip() {
        let sr = SourceRef {
            chunk_id: Uuid::new_v4(),
            timestamp: "2026-02-19T10:00:00".to_string(),
            source_app: "Teams".to_string(),
            relevance_score: 0.78,
        };
        let json = serde_json::to_string(&sr).unwrap();
        let rt: SourceRef = serde_json::from_str(&json).unwrap();
        assert_eq!(sr.chunk_id, rt.chunk_id);
        assert_eq!(sr.timestamp, rt.timestamp);
        assert_eq!(sr.source_app, rt.source_app);
        assert!((sr.relevance_score - rt.relevance_score).abs() < f32::EPSILON);
    }

    // ---- ConversationSession ----

    #[test]
    fn test_conversation_session_serde_round_trip() {
        let session = ConversationSession {
            id: Uuid::new_v4(),
            started_at: 1700000000,
            last_message_at: 1700001000,
            context: SessionContext::default(),
            message_count: 5,
        };
        let json = serde_json::to_string(&session).unwrap();
        let rt: ConversationSession = serde_json::from_str(&json).unwrap();
        assert_eq!(session.id, rt.id);
        assert_eq!(session.started_at, rt.started_at);
        assert_eq!(session.last_message_at, rt.last_message_at);
        assert_eq!(session.message_count, rt.message_count);
    }

    // ---- SessionContext ----

    #[test]
    fn test_session_context_default() {
        let ctx = SessionContext::default();
        assert!(ctx.recent_turns.is_empty());
        assert!(ctx.active_topic.is_none());
        assert!(ctx.active_time_range.is_none());
        assert!(ctx.active_person.is_none());
    }

    // ---- ChatMessage ----

    #[test]
    fn test_chat_message_serde_round_trip() {
        let msg = ChatMessage {
            id: Uuid::new_v4(),
            session_id: Uuid::new_v4(),
            role: "user".to_string(),
            content: "Hello".to_string(),
            sources: None,
            suggestions: None,
            created_at: 1700000000,
        };
        let json = serde_json::to_string(&msg).unwrap();
        let rt: ChatMessage = serde_json::from_str(&json).unwrap();
        assert_eq!(msg.id, rt.id);
        assert_eq!(msg.session_id, rt.session_id);
        assert_eq!(msg.role, rt.role);
        assert_eq!(msg.content, rt.content);
        assert!(rt.sources.is_none());
        assert!(rt.suggestions.is_none());
    }

    #[test]
    fn test_chat_message_with_sources() {
        let msg = ChatMessage {
            id: Uuid::new_v4(),
            session_id: Uuid::new_v4(),
            role: "assistant".to_string(),
            content: "Found results".to_string(),
            sources: Some(r#"[{"chunk_id":"00000000-0000-0000-0000-000000000000"}]"#.to_string()),
            suggestions: Some(r#"["Tell me more"]"#.to_string()),
            created_at: 1700000000,
        };
        let json = serde_json::to_string(&msg).unwrap();
        let rt: ChatMessage = serde_json::from_str(&json).unwrap();
        assert!(rt.sources.is_some());
        assert!(rt.suggestions.is_some());
    }

    // ---- API Types ----

    #[test]
    fn test_chat_request_serde() {
        let req = ChatRequest {
            message: "What did I discuss yesterday?".to_string(),
            session_id: None,
        };
        let json = serde_json::to_string(&req).unwrap();
        let rt: ChatRequest = serde_json::from_str(&json).unwrap();
        assert_eq!(req.message, rt.message);
        assert!(rt.session_id.is_none());
    }

    #[test]
    fn test_chat_request_with_session() {
        let sid = Uuid::new_v4();
        let req = ChatRequest {
            message: "Tell me more".to_string(),
            session_id: Some(sid),
        };
        let json = serde_json::to_string(&req).unwrap();
        let rt: ChatRequest = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.session_id, Some(sid));
    }

    #[test]
    fn test_chat_message_response_serde() {
        let resp = ChatMessageResponse {
            response: ChatResponseBody {
                answer: "Here are your results.".to_string(),
                sources: vec![],
                confidence: 0.9,
                suggestions: vec!["Try refining your query".to_string()],
            },
            session_id: Uuid::new_v4(),
        };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatMessageResponse = serde_json::from_str(&json).unwrap();
        assert_eq!(resp.response.answer, rt.response.answer);
        assert_eq!(resp.session_id, rt.session_id);
    }

    #[test]
    fn test_chat_history_response_serde() {
        let history = ChatHistoryResponse {
            messages: vec![
                ChatMessageRecord {
                    role: "user".to_string(),
                    content: "Hello".to_string(),
                    timestamp: "2026-02-19T10:00:00".to_string(),
                    sources: None,
                    suggestions: None,
                },
                ChatMessageRecord {
                    role: "assistant".to_string(),
                    content: "Hi there!".to_string(),
                    timestamp: "2026-02-19T10:00:01".to_string(),
                    sources: Some(vec![]),
                    suggestions: Some(vec!["What else?".to_string()]),
                },
            ],
        };
        let json = serde_json::to_string(&history).unwrap();
        let rt: ChatHistoryResponse = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.messages.len(), 2);
        assert_eq!(rt.messages[0].role, "user");
        assert_eq!(rt.messages[1].role, "assistant");
    }

    #[test]
    fn test_chat_sessions_response_serde() {
        let resp = ChatSessionsResponse {
            sessions: vec![ChatSessionSummary {
                id: Uuid::new_v4(),
                started_at: "2026-02-19T10:00:00".to_string(),
                last_message_at: "2026-02-19T10:05:00".to_string(),
                message_count: 10,
            }],
        };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatSessionsResponse = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.sessions.len(), 1);
        assert_eq!(rt.sessions[0].message_count, 10);
    }

    // ---- Config defaults ----

    #[test]
    fn test_chat_config_defaults() {
        let config = ChatConfig::default();
        assert!(config.enabled);
        assert_eq!(config.voice_hotkey, "Ctrl+Shift+E");
        assert_eq!(config.context_turns, 5);
        assert_eq!(config.session_timeout_minutes, 30);
        assert_eq!(config.max_voice_duration_seconds, 30);
        assert_eq!(config.default_search_days, 7);
        assert_eq!(config.max_results_per_query, 10);
    }

    #[test]
    fn test_chat_llm_config_defaults() {
        let config = ChatLlmConfig::default();
        assert!(!config.enabled);
        assert!(config.model_path.is_empty());
        assert_eq!(config.max_tokens, 512);
        assert!((config.temperature - 0.3).abs() < f32::EPSILON);
    }

    #[test]
    fn test_chat_config_serde_round_trip() {
        let config = ChatConfig::default();
        let json = serde_json::to_string(&config).unwrap();
        let rt: ChatConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(config.enabled, rt.enabled);
        assert_eq!(config.voice_hotkey, rt.voice_hotkey);
        assert_eq!(config.context_turns, rt.context_turns);
        assert_eq!(config.session_timeout_minutes, rt.session_timeout_minutes);
        assert_eq!(
            config.max_voice_duration_seconds,
            rt.max_voice_duration_seconds
        );
        assert_eq!(config.default_search_days, rt.default_search_days);
        assert_eq!(config.max_results_per_query, rt.max_results_per_query);
        assert_eq!(config.llm.enabled, rt.llm.enabled);
        assert_eq!(config.llm.max_tokens, rt.llm.max_tokens);
        assert!((config.llm.temperature - rt.llm.temperature).abs() < f32::EPSILON);
    }

    // ---- Edge Cases ----

    #[test]
    fn test_time_range_start_equals_end() {
        let tr = TimeRange {
            start: 1700000000,
            end: 1700000000,
        };
        let json = serde_json::to_string(&tr).unwrap();
        let rt: TimeRange = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.start, rt.end);
    }

    #[test]
    fn test_time_range_start_greater_than_end() {
        let tr = TimeRange {
            start: 1700003600,
            end: 1700000000,
        };
        // Should still serialize/deserialize (no validation at type level)
        let json = serde_json::to_string(&tr).unwrap();
        let rt: TimeRange = serde_json::from_str(&json).unwrap();
        assert!(rt.start > rt.end);
    }

    #[test]
    fn test_time_range_negative_values() {
        let tr = TimeRange {
            start: -1000,
            end: -500,
        };
        let json = serde_json::to_string(&tr).unwrap();
        let rt: TimeRange = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.start, -1000);
        assert_eq!(rt.end, -500);
    }

    #[test]
    fn test_time_range_zero_values() {
        let tr = TimeRange { start: 0, end: 0 };
        let json = serde_json::to_string(&tr).unwrap();
        let rt: TimeRange = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.start, 0);
        assert_eq!(rt.end, 0);
    }

    #[test]
    fn test_structured_query_empty_topics_and_people() {
        let sq = StructuredQuery {
            intent: QueryIntent::Search,
            topics: vec![],
            people: vec![],
            time_range: None,
            content_type: None,
            app_filter: None,
            raw_query: String::new(),
        };
        let json = serde_json::to_string(&sq).unwrap();
        let rt: StructuredQuery = serde_json::from_str(&json).unwrap();
        assert!(rt.topics.is_empty());
        assert!(rt.people.is_empty());
        assert!(rt.raw_query.is_empty());
    }

    #[test]
    fn test_structured_query_many_topics() {
        let topics: Vec<String> = (0..100).map(|i| format!("topic_{}", i)).collect();
        let sq = StructuredQuery {
            intent: QueryIntent::Search,
            topics: topics.clone(),
            people: vec![],
            time_range: None,
            content_type: None,
            app_filter: None,
            raw_query: "many topics".to_string(),
        };
        let json = serde_json::to_string(&sq).unwrap();
        let rt: StructuredQuery = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.topics.len(), 100);
        assert_eq!(rt.topics, topics);
    }

    #[test]
    fn test_chat_message_empty_content() {
        let msg = ChatMessage {
            id: Uuid::new_v4(),
            session_id: Uuid::new_v4(),
            role: "user".to_string(),
            content: String::new(),
            sources: None,
            suggestions: None,
            created_at: 0,
        };
        let json = serde_json::to_string(&msg).unwrap();
        let rt: ChatMessage = serde_json::from_str(&json).unwrap();
        assert!(rt.content.is_empty());
    }

    #[test]
    fn test_chat_message_long_content() {
        let long_content = "a".repeat(10_000);
        let msg = ChatMessage {
            id: Uuid::new_v4(),
            session_id: Uuid::new_v4(),
            role: "assistant".to_string(),
            content: long_content.clone(),
            sources: None,
            suggestions: None,
            created_at: 1700000000,
        };
        let json = serde_json::to_string(&msg).unwrap();
        let rt: ChatMessage = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.content.len(), 10_000);
    }

    #[test]
    fn test_chat_response_empty_sources_and_suggestions() {
        let resp = ChatResponse {
            answer: "No results".to_string(),
            sources: vec![],
            confidence: 0.0,
            suggestions: vec![],
        };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatResponse = serde_json::from_str(&json).unwrap();
        assert!(rt.sources.is_empty());
        assert!(rt.suggestions.is_empty());
        assert!((rt.confidence - 0.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_chat_response_confidence_boundary_zero() {
        let resp = ChatResponse {
            answer: "test".to_string(),
            sources: vec![],
            confidence: 0.0,
            suggestions: vec![],
        };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatResponse = serde_json::from_str(&json).unwrap();
        assert!((rt.confidence - 0.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_chat_response_confidence_boundary_one() {
        let resp = ChatResponse {
            answer: "test".to_string(),
            sources: vec![],
            confidence: 1.0,
            suggestions: vec![],
        };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatResponse = serde_json::from_str(&json).unwrap();
        assert!((rt.confidence - 1.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_source_ref_zero_relevance() {
        let sr = SourceRef {
            chunk_id: Uuid::new_v4(),
            timestamp: "2026-02-19T00:00:00".to_string(),
            source_app: String::new(),
            relevance_score: 0.0,
        };
        let json = serde_json::to_string(&sr).unwrap();
        let rt: SourceRef = serde_json::from_str(&json).unwrap();
        assert!((rt.relevance_score - 0.0).abs() < f32::EPSILON);
        assert!(rt.source_app.is_empty());
    }

    #[test]
    fn test_conversation_session_zero_message_count() {
        let session = ConversationSession {
            id: Uuid::new_v4(),
            started_at: 0,
            last_message_at: 0,
            context: SessionContext::default(),
            message_count: 0,
        };
        let json = serde_json::to_string(&session).unwrap();
        let rt: ConversationSession = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.message_count, 0);
        assert_eq!(rt.started_at, 0);
    }

    #[test]
    fn test_session_context_with_all_fields_set() {
        let ctx = SessionContext {
            recent_turns: vec![Turn {
                query: StructuredQuery {
                    intent: QueryIntent::Search,
                    topics: vec!["rust".to_string()],
                    people: vec![],
                    time_range: None,
                    content_type: None,
                    app_filter: None,
                    raw_query: "find rust".to_string(),
                },
                response: ChatResponse {
                    answer: "Found rust content".to_string(),
                    sources: vec![],
                    confidence: 0.8,
                    suggestions: vec![],
                },
            }],
            active_topic: Some("rust".to_string()),
            active_time_range: Some(TimeRange {
                start: 1700000000,
                end: 1700003600,
            }),
            active_person: Some("Alice".to_string()),
        };
        let json = serde_json::to_string(&ctx).unwrap();
        let rt: SessionContext = serde_json::from_str(&json).unwrap();
        assert_eq!(rt.recent_turns.len(), 1);
        assert_eq!(rt.active_topic, Some("rust".to_string()));
        assert_eq!(rt.active_person, Some("Alice".to_string()));
        assert!(rt.active_time_range.is_some());
    }

    #[test]
    fn test_chat_request_empty_message() {
        let req = ChatRequest {
            message: String::new(),
            session_id: None,
        };
        let json = serde_json::to_string(&req).unwrap();
        let rt: ChatRequest = serde_json::from_str(&json).unwrap();
        assert!(rt.message.is_empty());
    }

    #[test]
    fn test_chat_sessions_response_empty() {
        let resp = ChatSessionsResponse { sessions: vec![] };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatSessionsResponse = serde_json::from_str(&json).unwrap();
        assert!(rt.sessions.is_empty());
    }

    #[test]
    fn test_chat_history_response_empty() {
        let resp = ChatHistoryResponse { messages: vec![] };
        let json = serde_json::to_string(&resp).unwrap();
        let rt: ChatHistoryResponse = serde_json::from_str(&json).unwrap();
        assert!(rt.messages.is_empty());
    }

    #[test]
    fn test_chat_config_custom_values_serde() {
        let config = ChatConfig {
            enabled: false,
            voice_hotkey: "Ctrl+Alt+C".to_string(),
            context_turns: 10,
            session_timeout_minutes: 60,
            max_voice_duration_seconds: 60,
            default_search_days: 14,
            max_results_per_query: 20,
            llm: ChatLlmConfig {
                enabled: true,
                model_path: "/models/llama.gguf".to_string(),
                max_tokens: 1024,
                temperature: 0.7,
            },
        };
        let json = serde_json::to_string(&config).unwrap();
        let rt: ChatConfig = serde_json::from_str(&json).unwrap();
        assert!(!rt.enabled);
        assert_eq!(rt.voice_hotkey, "Ctrl+Alt+C");
        assert_eq!(rt.context_turns, 10);
        assert_eq!(rt.session_timeout_minutes, 60);
        assert_eq!(rt.max_voice_duration_seconds, 60);
        assert_eq!(rt.default_search_days, 14);
        assert_eq!(rt.max_results_per_query, 20);
        assert!(rt.llm.enabled);
        assert_eq!(rt.llm.model_path, "/models/llama.gguf");
        assert_eq!(rt.llm.max_tokens, 1024);
        assert!((rt.llm.temperature - 0.7).abs() < f32::EPSILON);
    }
}
