//! Obsidian vault export for insights.

use std::fs;
use std::path::{Path, PathBuf};

use engram_core::config::SafetyConfig;
use engram_core::safety::SafetyGate;

use crate::error::InsightError;
use crate::types::{DailyDigest, Entity, EntityType, Summary};

/// Exports summaries, entities, and digests to an Obsidian-compatible vault.
#[derive(Debug)]
pub struct VaultExporter {
    vault_path: PathBuf,
}

impl VaultExporter {
    /// Create a new vault exporter targeting the given directory.
    ///
    /// The path must be absolute (or start with `~`) and must not contain `..`
    /// to prevent directory traversal.
    pub fn new(vault_path: &str) -> Result<Self, InsightError> {
        let path = PathBuf::from(shellexpand_tilde(vault_path));
        // Security: validate path
        if vault_path.contains("..") {
            return Err(InsightError::Export("Path traversal detected".to_string()));
        }
        if !path.is_absolute() && !vault_path.starts_with('~') {
            return Err(InsightError::Export(
                "Vault path must be absolute".to_string(),
            ));
        }
        Ok(Self { vault_path: path })
    }

    /// Export a summary as a Markdown file under `summaries/`.
    pub fn export_summary(&self, summary: &Summary) -> Result<PathBuf, InsightError> {
        let dir = self.vault_path.join("summaries");
        fs::create_dir_all(&dir)?;

        let gate = default_safety_gate();
        let app = summary.source_app.as_deref().unwrap_or("unknown");
        let app_safe = sanitize_filename(app);
        let ts = format_timestamp_days(summary.time_range_start);
        let filename = format!("{}-{}.md", ts, app_safe);
        let path = dir.join(&filename);

        let mut content = format!("# {} -- {}\n\n", gate.redact(&summary.title), app);
        content.push_str("## Key Points\n\n");
        for point in &summary.bullet_points {
            content.push_str(&format!("- {}\n", gate.redact(point)));
        }
        content.push_str(&format!(
            "\n---\n\nSee also: [[daily/{}]]\n\n---\n*Generated by Engram*\n",
            ts
        ));

        atomic_write(&path, &content)?;
        Ok(path)
    }

    /// Export a daily digest as a Markdown file under `daily/`.
    pub fn export_digest(&self, digest: &DailyDigest) -> Result<PathBuf, InsightError> {
        let dir = self.vault_path.join("daily");
        fs::create_dir_all(&dir)?;

        let filename = format!("{}.md", &digest.digest_date);
        let path = dir.join(&filename);

        let mut content = format!("# Daily Digest -- {}\n\n", digest.digest_date);
        content.push_str("## Summary\n\n");
        content.push_str(&format!("- {} chunks captured\n", digest.chunk_count));
        content.push_str(&format!("- {} summaries generated\n", digest.summary_count));
        content.push_str(&format!("- {} entities extracted\n\n", digest.entity_count));

        if digest.summary_count > 0 {
            content.push_str("## Related Summaries\n\n");
            // Link to summaries directory; specific links require summary IDs
            // which are in the digest content JSON.
            if let Some(summaries) = digest.content.get("summary_ids").and_then(|v| v.as_array()) {
                for s in summaries {
                    if let Some(sid) = s.as_str() {
                        let safe = sanitize_filename(sid);
                        content.push_str(&format!("- [[summaries/{}]]\n", safe));
                    }
                }
            }
            content.push('\n');
        }

        content.push_str("---\n*Generated by Engram*\n");

        atomic_write(&path, &content)?;
        Ok(path)
    }

    /// Export person entities as a Markdown file under `entities/people.md`
    /// and project entities under `entities/projects.md`.
    pub fn export_entities(&self, entities: &[Entity]) -> Result<PathBuf, InsightError> {
        let dir = self.vault_path.join("entities");
        fs::create_dir_all(&dir)?;

        let gate = default_safety_gate();

        // --- people.md ---
        let people_path = dir.join("people.md");
        let mut people_content = String::from("# People Mentioned\n\n");
        let people: Vec<&Entity> = entities
            .iter()
            .filter(|e| e.entity_type == EntityType::Person)
            .collect();
        for p in &people {
            people_content.push_str(&format!("- {}\n", gate.redact(&p.value)));
        }
        atomic_write(&people_path, &people_content)?;

        // --- projects.md ---
        let projects_path = dir.join("projects.md");
        let mut projects_content = String::from("# Projects Mentioned\n\n");
        let projects: Vec<&Entity> = entities
            .iter()
            .filter(|e| e.entity_type == EntityType::Project)
            .collect();
        for p in &projects {
            // Projects are public names â€” no PII redaction needed.
            projects_content.push_str(&format!("- {}\n", p.value));
        }
        atomic_write(&projects_path, &projects_content)?;

        Ok(people_path)
    }
}

/// Create a default safety gate with all redaction enabled.
fn default_safety_gate() -> SafetyGate {
    SafetyGate::new(SafetyConfig::default())
}

/// Expand `~` at the start of a path to the `$HOME` directory.
fn shellexpand_tilde(path: &str) -> String {
    if let Some(rest) = path.strip_prefix("~/") {
        if let Ok(home) = std::env::var("HOME") {
            return format!("{}/{}", home, rest);
        }
    }
    path.to_string()
}

/// Replace non-alphanumeric characters (except `-` and `_`) with `_`.
fn sanitize_filename(s: &str) -> String {
    s.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '-' || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}

/// Simple day-number from epoch millis (for use in filenames).
fn format_timestamp_days(millis: i64) -> String {
    let secs = millis / 1000;
    let days = secs / 86400;
    format!("{}", days)
}

/// Write content atomically: write to a temp file then rename.
fn atomic_write(path: &Path, content: &str) -> Result<(), InsightError> {
    let dir = path
        .parent()
        .ok_or_else(|| InsightError::Export("Invalid path".to_string()))?;
    let temp = dir.join(format!(".tmp-{}", uuid::Uuid::new_v4()));
    fs::write(&temp, content)?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let _ = std::fs::set_permissions(&temp, std::fs::Permissions::from_mode(0o600));
    }

    fs::rename(&temp, path)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use uuid::Uuid;

    #[test]
    fn test_vault_exporter_path_traversal_rejected() {
        let result = VaultExporter::new("/home/user/../etc/vault");
        assert!(result.is_err());
        let err = result.unwrap_err().to_string();
        assert!(err.contains("traversal"), "Error: {}", err);
    }

    #[test]
    fn test_vault_exporter_relative_path_rejected() {
        let result = VaultExporter::new("relative/path/vault");
        assert!(result.is_err());
        let err = result.unwrap_err().to_string();
        assert!(err.contains("absolute"), "Error: {}", err);
    }

    #[test]
    fn test_vault_exporter_absolute_path_accepted() {
        let path = if cfg!(windows) {
            "C:\\Users\\test\\vault"
        } else {
            "/tmp/test-vault"
        };
        let result = VaultExporter::new(path);
        assert!(result.is_ok(), "Failed for path {}: {:?}", path, result.err());
    }

    #[test]
    fn test_vault_exporter_tilde_path_accepted() {
        let result = VaultExporter::new("~/vault");
        assert!(result.is_ok());
    }

    #[test]
    fn test_sanitize_filename() {
        assert_eq!(sanitize_filename("hello-world"), "hello-world");
        assert_eq!(sanitize_filename("my app/v2"), "my_app_v2");
        assert_eq!(sanitize_filename("test_file"), "test_file");
    }

    #[test]
    fn test_export_summary_creates_file() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap()).unwrap();

        let summary = Summary {
            id: Uuid::new_v4(),
            title: "Test Summary".to_string(),
            bullet_points: vec!["Point one".into(), "Point two".into()],
            source_chunk_ids: vec![Uuid::new_v4()],
            source_app: Some("vscode".to_string()),
            time_range_start: 1_700_000_000_000,
            time_range_end: 1_700_001_000_000,
            created_at: 1_700_001_000_000,
        };

        let path = exporter.export_summary(&summary).unwrap();
        assert!(path.exists(), "Summary file should exist at {:?}", path);

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("Test Summary"));
        assert!(content.contains("Point one"));
        assert!(content.contains("Point two"));
        assert!(content.contains("Generated by Engram"));

        // Cleanup
        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_summary_has_wikilink() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap()).unwrap();

        let summary = Summary {
            id: Uuid::new_v4(),
            title: "Wikilink Test".to_string(),
            bullet_points: vec!["Point".into()],
            source_chunk_ids: vec![Uuid::new_v4()],
            source_app: Some("vscode".to_string()),
            time_range_start: 1_700_000_000_000,
            time_range_end: 1_700_001_000_000,
            created_at: 1_700_001_000_000,
        };

        let path = exporter.export_summary(&summary).unwrap();
        let content = fs::read_to_string(&path).unwrap();
        assert!(
            content.contains("[[daily/"),
            "Summary should contain wikilink to daily digest"
        );

        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_summary_redacts_pii() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap()).unwrap();

        let summary = Summary {
            id: Uuid::new_v4(),
            title: "Meeting with user@example.com".to_string(),
            bullet_points: vec!["Contact alice@test.com for details".into()],
            source_chunk_ids: vec![Uuid::new_v4()],
            source_app: Some("vscode".to_string()),
            time_range_start: 1_700_000_000_000,
            time_range_end: 1_700_001_000_000,
            created_at: 1_700_001_000_000,
        };

        let path = exporter.export_summary(&summary).unwrap();
        let content = fs::read_to_string(&path).unwrap();
        assert!(
            !content.contains("user@example.com"),
            "PII should be redacted from summary"
        );
        assert!(
            content.contains("[EMAIL_REDACTED]"),
            "Redaction token should appear"
        );

        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_digest_creates_file() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap()).unwrap();

        let digest = DailyDigest {
            id: Uuid::new_v4(),
            digest_date: "2026-02-18".to_string(),
            content: serde_json::json!({}),
            summary_count: 5,
            entity_count: 10,
            chunk_count: 42,
            created_at: 1_700_000_000_000,
        };

        let path = exporter.export_digest(&digest).unwrap();
        assert!(path.exists(), "Digest file should exist at {:?}", path);

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("2026-02-18"));
        assert!(content.contains("42 chunks captured"));
        assert!(content.contains("5 summaries generated"));
        assert!(content.contains("10 entities extracted"));

        // Cleanup
        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_entities_creates_file() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap()).unwrap();

        let entities = vec![
            Entity {
                id: Uuid::new_v4(),
                entity_type: EntityType::Person,
                value: "Alice".to_string(),
                source_chunk_id: Uuid::new_v4(),
                source_summary_id: None,
                confidence: 0.9,
                created_at: 1000,
            },
            Entity {
                id: Uuid::new_v4(),
                entity_type: EntityType::Url,
                value: "https://example.com".to_string(),
                source_chunk_id: Uuid::new_v4(),
                source_summary_id: None,
                confidence: 1.0,
                created_at: 1000,
            },
        ];

        let path = exporter.export_entities(&entities).unwrap();
        assert!(path.exists());

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("Alice"));
        // URL entity should NOT appear in people file
        assert!(!content.contains("https://example.com"));

        // Cleanup
        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_entities_creates_projects_file() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap()).unwrap();

        let entities = vec![
            Entity {
                id: Uuid::new_v4(),
                entity_type: EntityType::Person,
                value: "Alice".to_string(),
                source_chunk_id: Uuid::new_v4(),
                source_summary_id: None,
                confidence: 0.9,
                created_at: 1000,
            },
            Entity {
                id: Uuid::new_v4(),
                entity_type: EntityType::Project,
                value: "Engram".to_string(),
                source_chunk_id: Uuid::new_v4(),
                source_summary_id: None,
                confidence: 0.95,
                created_at: 1000,
            },
        ];

        let _ = exporter.export_entities(&entities).unwrap();

        let projects_path = dir.join("entities/projects.md");
        assert!(projects_path.exists(), "projects.md should exist");

        let content = fs::read_to_string(&projects_path).unwrap();
        assert!(
            content.contains("Engram"),
            "projects.md should contain Engram"
        );
        assert!(
            !content.contains("Alice"),
            "projects.md should not contain people"
        );

        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_entities_redacts_pii_in_people() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap()).unwrap();

        let entities = vec![Entity {
            id: Uuid::new_v4(),
            entity_type: EntityType::Person,
            value: "Alice alice@secret.com".to_string(),
            source_chunk_id: Uuid::new_v4(),
            source_summary_id: None,
            confidence: 0.9,
            created_at: 1000,
        }];

        let _ = exporter.export_entities(&entities).unwrap();

        let people_path = dir.join("entities/people.md");
        let content = fs::read_to_string(&people_path).unwrap();
        assert!(
            !content.contains("alice@secret.com"),
            "PII should be redacted from people entities"
        );
        assert!(content.contains("[EMAIL_REDACTED]"));

        let _ = fs::remove_dir_all(&dir);
    }

    #[cfg(unix)]
    #[test]
    fn test_atomic_write_sets_permissions() {
        use std::os::unix::fs::PermissionsExt;

        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        fs::create_dir_all(&dir).unwrap();
        let path = dir.join("perms-test.md");

        atomic_write(&path, "test content").unwrap();
        let metadata = fs::metadata(&path).unwrap();
        let mode = metadata.permissions().mode() & 0o777;
        assert_eq!(mode, 0o600, "File should have 0600 permissions");

        let _ = fs::remove_dir_all(&dir);
    }
}
