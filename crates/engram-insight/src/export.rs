//! Obsidian vault export for insights.

use std::fs;
use std::path::{Path, PathBuf};

use crate::error::InsightError;
use crate::types::{DailyDigest, Entity, EntityType, Summary};

/// Exports summaries, entities, and digests to an Obsidian-compatible vault.
#[derive(Debug)]
pub struct VaultExporter {
    vault_path: PathBuf,
    #[allow(dead_code)]
    format: String,
}

impl VaultExporter {
    /// Create a new vault exporter targeting the given directory.
    ///
    /// The path must be absolute (or start with `~`) and must not contain `..`
    /// to prevent directory traversal.
    pub fn new(vault_path: &str, format: &str) -> Result<Self, InsightError> {
        let path = PathBuf::from(shellexpand_tilde(vault_path));
        // Security: validate path
        if vault_path.contains("..") {
            return Err(InsightError::Export("Path traversal detected".to_string()));
        }
        if !path.is_absolute() && !vault_path.starts_with('~') {
            return Err(InsightError::Export(
                "Vault path must be absolute".to_string(),
            ));
        }
        Ok(Self {
            vault_path: path,
            format: format.to_string(),
        })
    }

    /// Export a summary as a Markdown file under `summaries/`.
    pub fn export_summary(&self, summary: &Summary) -> Result<PathBuf, InsightError> {
        let dir = self.vault_path.join("summaries");
        fs::create_dir_all(&dir)?;

        let app = summary.source_app.as_deref().unwrap_or("unknown");
        let app_safe = sanitize_filename(app);
        let ts = format_timestamp_days(summary.time_range_start);
        let filename = format!("{}-{}.md", ts, app_safe);
        let path = dir.join(&filename);

        let mut content = format!("# {} -- {}\n\n", summary.title, app);
        content.push_str("## Key Points\n\n");
        for point in &summary.bullet_points {
            content.push_str(&format!("- {}\n", point));
        }
        content.push_str("\n---\n*Generated by Engram*\n");

        atomic_write(&path, &content)?;
        Ok(path)
    }

    /// Export a daily digest as a Markdown file under `daily/`.
    pub fn export_digest(&self, digest: &DailyDigest) -> Result<PathBuf, InsightError> {
        let dir = self.vault_path.join("daily");
        fs::create_dir_all(&dir)?;

        let filename = format!("{}.md", &digest.digest_date);
        let path = dir.join(&filename);

        let mut content = format!("# Daily Digest -- {}\n\n", digest.digest_date);
        content.push_str("## Summary\n\n");
        content.push_str(&format!("- {} chunks captured\n", digest.chunk_count));
        content.push_str(&format!("- {} summaries generated\n", digest.summary_count));
        content.push_str(&format!("- {} entities extracted\n\n", digest.entity_count));
        content.push_str("---\n*Generated by Engram*\n");

        atomic_write(&path, &content)?;
        Ok(path)
    }

    /// Export person entities as a Markdown file under `entities/`.
    pub fn export_entities(&self, entities: &[Entity]) -> Result<PathBuf, InsightError> {
        let dir = self.vault_path.join("entities");
        fs::create_dir_all(&dir)?;
        let path = dir.join("people.md");

        let mut content = String::from("# People Mentioned\n\n");
        let people: Vec<&Entity> = entities
            .iter()
            .filter(|e| e.entity_type == EntityType::Person)
            .collect();
        for p in &people {
            content.push_str(&format!("- {}\n", p.value));
        }

        atomic_write(&path, &content)?;
        Ok(path)
    }
}

/// Expand `~` at the start of a path to the `$HOME` directory.
fn shellexpand_tilde(path: &str) -> String {
    if let Some(rest) = path.strip_prefix("~/") {
        if let Ok(home) = std::env::var("HOME") {
            return format!("{}/{}", home, rest);
        }
    }
    path.to_string()
}

/// Replace non-alphanumeric characters (except `-` and `_`) with `_`.
fn sanitize_filename(s: &str) -> String {
    s.chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '-' || c == '_' {
                c
            } else {
                '_'
            }
        })
        .collect()
}

/// Simple day-number from epoch millis (for use in filenames).
fn format_timestamp_days(millis: i64) -> String {
    let secs = millis / 1000;
    let days = secs / 86400;
    format!("{}", days)
}

/// Write content atomically: write to a temp file then rename.
fn atomic_write(path: &Path, content: &str) -> Result<(), InsightError> {
    let dir = path
        .parent()
        .ok_or_else(|| InsightError::Export("Invalid path".to_string()))?;
    let temp = dir.join(format!(".tmp-{}", uuid::Uuid::new_v4()));
    fs::write(&temp, content)?;
    fs::rename(&temp, path)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use uuid::Uuid;

    #[test]
    fn test_vault_exporter_path_traversal_rejected() {
        let result = VaultExporter::new("/home/user/../etc/vault", "markdown");
        assert!(result.is_err());
        let err = result.unwrap_err().to_string();
        assert!(err.contains("traversal"), "Error: {}", err);
    }

    #[test]
    fn test_vault_exporter_relative_path_rejected() {
        let result = VaultExporter::new("relative/path/vault", "markdown");
        assert!(result.is_err());
        let err = result.unwrap_err().to_string();
        assert!(err.contains("absolute"), "Error: {}", err);
    }

    #[test]
    fn test_vault_exporter_absolute_path_accepted() {
        let result = VaultExporter::new("/tmp/test-vault", "markdown");
        assert!(result.is_ok());
    }

    #[test]
    fn test_vault_exporter_tilde_path_accepted() {
        let result = VaultExporter::new("~/vault", "markdown");
        assert!(result.is_ok());
    }

    #[test]
    fn test_sanitize_filename() {
        assert_eq!(sanitize_filename("hello-world"), "hello-world");
        assert_eq!(sanitize_filename("my app/v2"), "my_app_v2");
        assert_eq!(sanitize_filename("test_file"), "test_file");
    }

    #[test]
    fn test_export_summary_creates_file() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap(), "markdown").unwrap();

        let summary = Summary {
            id: Uuid::new_v4(),
            title: "Test Summary".to_string(),
            bullet_points: vec!["Point one".into(), "Point two".into()],
            source_chunk_ids: vec![Uuid::new_v4()],
            source_app: Some("vscode".to_string()),
            time_range_start: 1_700_000_000_000,
            time_range_end: 1_700_001_000_000,
            created_at: 1_700_001_000_000,
        };

        let path = exporter.export_summary(&summary).unwrap();
        assert!(path.exists(), "Summary file should exist at {:?}", path);

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("Test Summary"));
        assert!(content.contains("Point one"));
        assert!(content.contains("Point two"));
        assert!(content.contains("Generated by Engram"));

        // Cleanup
        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_digest_creates_file() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap(), "markdown").unwrap();

        let digest = DailyDigest {
            id: Uuid::new_v4(),
            digest_date: "2026-02-18".to_string(),
            content: serde_json::json!({}),
            summary_count: 5,
            entity_count: 10,
            chunk_count: 42,
            created_at: 1_700_000_000_000,
        };

        let path = exporter.export_digest(&digest).unwrap();
        assert!(path.exists(), "Digest file should exist at {:?}", path);

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("2026-02-18"));
        assert!(content.contains("42 chunks captured"));
        assert!(content.contains("5 summaries generated"));
        assert!(content.contains("10 entities extracted"));

        // Cleanup
        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_export_entities_creates_file() {
        let dir = std::env::temp_dir().join(format!("engram-test-{}", Uuid::new_v4()));
        let exporter = VaultExporter::new(dir.to_str().unwrap(), "markdown").unwrap();

        let entities = vec![
            Entity {
                id: Uuid::new_v4(),
                entity_type: EntityType::Person,
                value: "Alice".to_string(),
                source_chunk_id: Uuid::new_v4(),
                source_summary_id: None,
                confidence: 0.9,
                created_at: 1000,
            },
            Entity {
                id: Uuid::new_v4(),
                entity_type: EntityType::Url,
                value: "https://example.com".to_string(),
                source_chunk_id: Uuid::new_v4(),
                source_summary_id: None,
                confidence: 1.0,
                created_at: 1000,
            },
        ];

        let path = exporter.export_entities(&entities).unwrap();
        assert!(path.exists());

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("Alice"));
        // URL entity should NOT appear in people file
        assert!(!content.contains("https://example.com"));

        // Cleanup
        let _ = fs::remove_dir_all(&dir);
    }
}
